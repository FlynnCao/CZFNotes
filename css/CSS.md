## CSS - cascading style sheet

## 基本构成

1. 样式表
2. 规则
3. 选择器+声明块
4. 声明
5. CSS属性+CSS属性值组成的键值对

```css
p{
 color:red;
 font-size:13px;
}
```

```css
div ul li #test{
    
}
```

:warning:选择器并无优先级，优先级是针对声明的！

## 大纲

* 选择器
* 自定义字体
* 新的UI方案
* 过渡
* 2d/3d变形
* 动画
* 布局拓展
* 变量和函数

## 基本选择器

基本选择器：

* id `#{}`
* class类选择器 `.{}`
* 元素选择器 `p{}`
* 通配符选择器/后代选择器 `p span{}`
* 分组选择器 `.rectangle,.circle{}`

:warning: id选择器已经有了唯一性，不推荐与其他选择器混用

## 复合选择器

* 交集选择器：选择满足多个选择器条件对应的元素： **and**

> 交集选择器中如果有元素选择器，必须使用元素选择器开头

```css
.usa.china{color:red}
```

* 并集选择器（选择器分组）：同时选择多个选择器对应的元素 : **or**

```css
h1,span{color:green;}
```

:tada:  不同类型的选择器可以使用以上规则混用，无限组合

## 关系选择器

### 说明

* 父元素：**直接**包含子元素的元素叫做父元素
* 子元素：**直接**被父元素包含的元素叫做父元素
* 祖先元素：**直接或间接**包含后代元素的元素叫做祖先元素；一个元素的父元素也是祖先元素
* 后代元素：**直接或间接**被祖先元素包含的元素叫做后代元素；子元素也是后代元素
* 兄弟元素：拥有相同父元素的元素是兄弟元素

### 语法

子元素选择器： `.box>p{}` 选择指定父元素的指定子元素

后代元素选择器： `.box p{} ` 选择指定元素内的指定后代元素

相邻兄弟选择器： `.center + .neighbour{}` 选择下一个兄弟

> 目标的兄弟是文档流中下一个紧跟的元素，会被其他元素阻断

通用兄弟选择器：`.center ~ .neighbour{}` 选择下面所有的兄弟

> 目标的兄弟是文档中下几个同级的元素，不会被其他元素阻断

:flags:  ​学习定义的时候需要注意

* 默认值
* 属性是否可以继承

## 属性选择器

`p[nickname]` 选择含有唯一指定属性名的元素

`p[nickname="pony"]` 选择含有**唯一**指定属性值的元素

> Boolean Number等其他类型同理

`p[nickname~="pony"] `选择包含有指定属性值的元素

> 当属性值有多个时，使用此语法块定义的声明生效

模糊匹配：

`[属性名^=属性值]` 指定属性值开头的元素

`[属性名$=属性值]` 指定属性值结束的元素

`[属性名*=属性值]` 属性值中含有某值的元素

## 伪类 :

### 关系伪类

伪类即不存在的类，用来描述一个元素的**特殊状态**，比如第一个子元素，被点击、聚焦、悬浮的元素。

> 可以把`:XXX`看做是一个`.XXX`类，`p:hover`中的p和hover是and关系

在CSS3+标准的语法中，伪类统一使用冒号开头，具体有：

* `:first-child` 是父元素的第一个子元素
* `:last-child`是父元素的最后一个子元素
* `:nth-child(n)`是父元素的指定子元素

> n为确定的数字（0-正无穷），如果写n代表全部选中，2n/even代表偶数，2n-1/odd代表奇数

`:first-of-type` 是父元素的第一个指定类型的子元素

`:last-of-type` 是父元素的最后一个指定类型子元素

`:nth-of-type ` 是父元素自定义位置的指定类型子元素



`:not` 否定伪类，将符合条件的元素从选择器中去除

> not嵌套其他选择器使用

### 事件伪类

`a:link` 正常的链接（默认）

`a:visited` 访问过的链接

`a:target`

> 由于隐私原因，:visited只能修改颜色

> link+visited > hover +  active 

`div:hover` 鼠标悬浮在元素上方时

`div:active`鼠标正在点击元素时

`input:focus`鼠标聚焦元素时

## 伪元素 ::

伪元素是一个附加至选择器末的关键词 `::`，允许你对被选择元素的**特定部分**修改样式。

> 因为样式是需要应用于元素的，伪元素相当于为特定部分包裹标签，然后单独修改其样式

`::first-letter`第一个字母

`::first-line`第一行

`::selection` 光标选中的内容



`::before`指定元素的所有内容之前的位置

`::after`指定元素的所有内容之后的位置

> 相当于元素innerHTML之前

使用`::before`和​`::after`必须结合`content`属性来使用

此方法生成的元素无法被选中。

:car:例子：

```html
<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<style>
		div::before {
			content: '我想看到:';
		}
		div::after {
			content: '就是这样';
			color: red;
		}
	</style>
</head>

<body>
	<div>
		Hello Javascript!
	</div>
</body>
</html>
```

具体效果：

![image-20210505195401593](https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210505195401593.png)

> 例如html5的q标签会自动在开头和结尾使用伪元素语法加上`""`



:pencil2:CSS选择器餐厅练习 [CSS Diner - Where we feast on CSS Selectors! (flukeout.github.io)](https://flukeout.github.io/)

## 样式继承

我们为一个元素设置的样式也会应用到他的后代元素。继承是发生在**祖先**和**后代元素**之间的。

继承的设计是为了方便我们的开发，利用继承我们可以将一些通用的样式统一设置到我们共同的祖先元素上，这样我们只需设置一次即可让我们所有的元素都具有该样式。

> 背景相关的、布局相关的等不会被继承

在MDN Web Docs可以查询一个样式是否能被继承

## 选择器的权重

:bomb:样式冲突：当我们通过不同的选择器，选择相同的元素，并且为相同的样式设置不同的值时，此时就发生了冲突

发生样式冲突时，应该用哪个样式由选择器的权重决定

选择器的权重：(由高到低)

* 内联  1,0,0,0 
*  id选择器  1,0,0
*  类和伪类选择器  1,0 
* 元素选择器   1 
* 通配选择器  0
* 继承的样式 NaN

![image-20210509164616264](https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210509164616264.png)

交集：比较优先级时，需要将所有选择器的优先级进行相加计算，最后优先级越高，则越优先显示

并集：分组选择器分别进行计算，取最大的权重

:bulb:选择器的累加不可能超过其数量级

>  11个**id选择器**交集也不会超过**内联**样式的权重

:black_flag: 选择器越具体，优先级越高

:flags:如果选择器的优先级相等，优先使用新出现的

:warning:给样式后面加入`!important`关键字可以将优先级设置为最高（超过内联）；慎用

## 像素和百分比

像素：

* 屏幕（显示器）实际上是由一个一个发光的小点组成的

* 不同屏幕的像素观感大小是不同的，同样尺寸的屏幕像素点越小整体观感越清晰

百分比：

* 可以将属性值设置为相对其父元素属性的百分比值
* 设置百分比可以使子元素跟随父元素的改变而改变

em:

* 相对于**当前元素**的字体大小来计算
* 1em = 1 font size (宽×高)； 10 em = 10 font size
* 跟随字体大小的改变而改变

> font-size的具体大小根据字体和语言的不同而变化，宽高不一定和给定的一致

例子：以下三种类所描绘的div大小一致

```css
	    .box1 {
			width: 200px;
			height: 200px;
			background-color: orange;
		}

		.box2 {
			width: 50%;
			height: 50%;
			background-color: palevioletred;
		}

		.box3 {
			font-size: 20px;
			width: 10em;
			height: 10em;
			background-color: lightblue;
		}
```

> rem是相对于**根元素**的字体大小即`html{}`来计算的，html的font-size一般默认为16px

## 颜色单位

在CSS中可以直接使用颜色名来设置各种颜色，但是在CSS中直接使用颜色名十分不方便

实际中我们主要使用RBG值来表示（注意是光的三原色：红绿蓝）

RGB就是通过三种不同颜色的浓度来调配出不同的颜色。

每一种颜色的范围在 0 - 255之间（0 - 100% ） 之间

RGB：

* `rgb(0,0,0)` => 黑色

* `rgb(255,255,255)`=>白色

* `rgb(255, 0, 0)`=>红色

* `rgb(0, 255, 0)`=>绿色

* `rgb(0,0,255)`=>蓝色


:bulb:RGBA就是在RBG的基础上增加了一个Alpha通道表示不透明度（范围0.0-1.0，1=100%完全不透明）

十六进制的RGB值：

* 语法：`#红色绿色蓝色`
* 范围：00  -  FF
* 白色：`#FFFFFF`
* 黑色：`#000000` 

> 如果两位两位重复则可以进行简写，如 #BFA - > #BBFFAA

*HSL值、HSLA值：（色相、饱和度、亮度、不透明度）

* Hue (0-360)
* Saturation (0%-100%)
* Lightness  (0%-100%)
* Alpha(0-1)

## 文档流 normal flow

网页是一个多层的结构，一层摞着一层（z-index)，通过CSS可以分别为每一层来设置样式，作为用户来讲只能够看到最上面的一层，这些层中，最底层的一层就叫做**文档流**，文档流是网页的基础

我们所创建的元素默认都是在文档流中进行排列的

:heart:对于我们来说，元素主要有两个状态，一个是在文档流中，一个不在文档流中（脱离文档流）



元素在文档流时的特点：

* 块元素：

  * 默认宽度是父元素的100%，充满一行
  * 默认高度被内容撑开（子元素）
  * 自上向下垂直排列

* 行内元素：

  * 默认宽度和高度总是被其内容所撑开

  * 行内元素不会独占页面一行，只占自身的大小

  * 行内元素在页面中自左向右水平排列

  * 如果一行之中不能容纳下所有的行内元素，则元素会换到第二行继续自左向右排列

    

## 盒模型 box model

CSS 将页面中的所有元素都设置成了矩形的盒子

将元素物化为矩形的盒子后，对页面的布局就变成了将不同的盒子摆放到不同的位置

每一个盒子都由以下几个部分组成

* 内容区 content （ 文字、子元素等）
* 边框 border 
* 内边距 padding
* 外边距 margin

![](https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210509183939177.png)

对一个元素设置的`width`和`height`属性值指定了内容区(content)的大小

### 边框

指定border需要颜色(border-color)厚度（border-width)和样式（border-style)

> 注意，在默认情况下如果设置了border宽度为10px而其他不变，则盒子宽高各增加10px，如果给定width:200px;height:200px，则盒子实际大小为宽220px*高220px

![image-20210509184838864](https://image-1256777099.cos.ap-beijing-fsi.myqcloud.com/image-20210509184838864.png)