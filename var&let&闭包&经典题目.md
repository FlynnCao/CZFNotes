# JavaScript中的var、let区别以及闭包 and 经典题目	

[toc]

![u=1894241208,139720229&fm=26&gp=0](images/var&let&%E9%97%AD%E5%8C%85&%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/u=1894241208,139720229&fm=26&gp=0.jpg)

## 闭包

闭包的原因：在原生的ES5内只存在 **函数作用域**(var)和 **全局作用域**(var) ，声明在函数体内的则为函数作用域，否则为全局。

使用以下方式可以利用这个特性创建一个闭包（closure)，用来对变量进行保护

例子：我想保护`local`变量不被外界随意修改：

```js
function foo(){
  var local = 1
  function bar(){
    local++
    return local
  }
  return bar
}

var func = foo()
func()
```

> 在上述例子中，local变量组成了一个闭包

let的方法和闭包的方法原理类似，都是每一轮循环产生一个私有的作用域，（LET块级作用域），保存住当前循环i的值，以供后期调用。

## 腾讯面试题改

**题目：判断以下代码的输出结果**

```js
for(var i=0;i<=3;i++){ setTimeout(function() { console.log(i) }, 10) }
```

**答案：控制台将会输出3个3**

分析：每一次for循环的时候，setTimeout都执行一次， 但是里面的函数没有被执行，而是被放到了任务队列里面，等待执行， for循环了4次，就放了4次，当主线程执行完成后，才进入任务队列里面执行。

> setTimeout()是一个异步处理函数，它会等待所有的主线程任务处理完，才开始执行自己的内部的任务，每隔1s往任务队列中添加一个任务【闭包函数，setTimeout()中的函数，现在还没执行】，当主线程执行完时，这时i=3

**新增题目：如何让控制台输出 0  1  和 2？** 

for循环头部的let不仅将i绑定到for循环块中， 它也将其重新绑定到 **循环体的每一次迭代** 中，确保上一次迭代结束的值重新被赋值。 setTimeout里面的function()属于一个新的域， 通过 var 定义的变量是无法传入到这个函数执行域中的， 而通过使用 let 来声明块变量，这时候变量就能作用于这个块， 所以 function就能使用 i 这个变量了； 这个匿名函数的参数作用域 和 for参数的作用域 不一样。

